# 調停ロジック詳細

## 概要
本ドキュメントは、eminj_l_mat.cにおける優先調停ロジックの詳細を説明します。

## 仕様書要求との対応

### 仕様書記載内容（セクションB 要求1-2）
> 各機能が要求する噴射方式を集約して最適な混合気を形成する為に、機能の優先調停を行う。
> 
> 優先度は、噴射停止、工場での制御の制御を優先し、その後、始動時、始動後の制御の順で優先度を決めている。その中でも、ドラビリ、エミッション、部品保護、性能の順で優先度の高さを設定する。

### コード実装箇所
- `vdg_eminj_8msm()` 関数内（行815-2593）
- 優先度判定ロジック（行1102-1500程度）
- 調停テーブル処理（行2033-2217）

---

## 調停の3つのフェーズ

### 1. 始動時調停（Starting Phase）
**条件:** `u1s_eminj_estpri != 0`

**対象機能:**
- 始動時に特化した制御
- 始動性向上のための特別制御

**特徴:**
- 最も高い優先度を持つ
- 始動時テーブル（`stt_eminj_tbl[]`）から選択

---

### 2. 始動後調停（After-Start Phase）
**条件:** `u1s_eminj_estpri == 0 && u1s_eminj_eastpri != 0`

**対象機能:**
- 始動直後の暖機制御
- 始動から定常への移行制御

**特徴:**
- 始動時の次に高い優先度
- 始動時に調停された機能が始動後も継続される仕組み
- 始動後テーブルから選択

**継続性の実装:**
```c
// 始動時に調停された機能が始動後も優先される
if ( 始動時調停機能が始動後テーブルにも存在 ) {
    // その機能を継続
} else {
    // 始動後テーブルから新規選択
}
```

---

### 3. 通常調停（Normal Phase）
**条件:** `u1s_eminj_estpri == 0 && u1s_eminj_eastpri == 0`

**対象機能:**
- 定常運転時の制御
- 性能・エミッション・燃費制御

**特徴:**
- 最も基本的な調停
- 通常テーブルから選択

---

## 優先度の階層構造

### レベル1: フェーズ別優先度
```
始動時 > 始動後 > 通常
```

### レベル2: 機能種別優先度（仕様書記載）
```
噴射停止 > 工場制御 > ドラビリ > エミッション > 部品保護 > 性能
```

### レベル3: ID別優先度
各テーブル内でIDの小さい順に高優先度

---

## 優先度判定の実装

### 主要変数

```c
static u1 u1s_eminj_estpri;      // 始動時要求の優先度
static u1 u1s_eminj_estpri2;     // 始動時要求2の優先度
static u1 u1s_eminj_estprir;     // 始動時要求と始動時要求2間の優先度選択
static u1 u1s_eminj_eastpri;     // 始動後要求の優先度
static u1 u1s_eminj_eastpri2;    // 始動後要求2の優先度
static u1 u1s_eminj_exastmedi;   // 始動後要求調停対象フラグ
static u1 u1s_eminj_epri;        // 通常要求の優先度
static u1 u1s_eminj_epri2;       // 通常要求2の優先度
static u1 u1s_eminj_eprisel_fix; // 最高優先度
static u1 u1s_eminj_eprifix;     // 確定優先度
```

### 優先度選択フロー

```
1. 始動時優先度チェック
   └─ u1s_eminj_estpri != 0?
       ├─ YES: 始動時調停へ
       └─ NO: 2へ

2. 始動後優先度チェック
   └─ u1s_eminj_eastpri != 0?
       ├─ YES: 始動後調停へ
       └─ NO: 3へ

3. 通常調停
   └─ u1s_eminj_epri使用
```

---

## 調停テーブル構造

### テーブル定義の例

```c
static const st_EMINJ_EMINJ_TBL stt_eminj_tbl[] = {
    { dataget_function_1, ID_1 },
    { dataget_function_2, ID_2 },
    { dataget_function_3, ID_3 },
    // ...
    { vds_eminj_dummy_emedi_dataget, 0 }  // 終端
};
```

### テーブル走査処理

**コード位置:** 行2033-2217（推定）

**ロジック:**
```c
for ( ID順にループ ) {
    if ( 該当IDの機能が要求中 && IDが優先度に一致 ) {
        // データ取得関数を呼び出し
        stt_eminj_tbl[index].pt_dataget( &buffer );
        break;
    }
}
```

**特徴:**
- ID順（昇順）に走査
- 最初に見つかった一致機能を選択
- 選択後は即座にループを抜ける（早期終了）

---

## 始動時から始動後への継続制御

### 仕様書記載
> 両テーブルに挿している機能の中では始動時に調停された機能が始動後も優先的に調停される

### 実装方法

#### ステップ1: 始動時調停
```c
// 始動時
u1s_eminj_estpri = XX;  // 機能Aが最高優先度
u1g_eminj_einjmedislid = ID_A;  // 機能AのIDを記憶
```

#### ステップ2: 始動完了判定
```c
if ( 始動完了 ) {
    u1s_eminj_exast_lch = ON;  // 始動完了をラッチ
}
```

#### ステップ3: 始動後調停
```c
// 始動後
if ( u1s_eminj_exast_lch == ON ) {
    // 始動時に選択された機能（ID_A）が始動後テーブルにも存在？
    if ( 機能Aが始動後テーブルに存在 ) {
        // 機能Aを継続して調停
        u1s_eminj_eastpri = ID_A;
    } else {
        // 始動後テーブルから新規選択
        u1s_eminj_eastpri = 始動後最高優先度;
    }
}
```

---

## 調停結果の記憶

### 調停ID
**変数:** `u1g_eminj_einjmedislid`
**型:** u1（符号なし8bit整数）

**用途:**
- 現在調停されている機能のIDを保持
- 次回調停時の継続判定に使用
- デバッグ・診断での機能特定

---

### 要求記憶ID
**変数:** `u4s_eminj_erqdat[2]`
**型:** u4配列（2要素）

**用途:**
- [0]: 旧構造体の要求フラグ記憶
- [1]: 新構造体の要求フラグ記憶
- 要求の履歴管理

---

## データ取得と統合

### 各機能のdataget関数

**プロトタイプ:**
```c
void vdg_xxx_emedi_dataget( st_EMINJ_EMINJ_DEF * ptt_store );
```

**処理内容:**
1. 自機能の要求をバッファに格納
   - 優先度
   - 要求フラグ
   - 噴射パラメータ

2. 必要に応じて他モジュールのデータを参照

3. バッファを返す

---

### データ統合処理

#### 基本値との統合
```c
// 基本値を設定
st_EMINJ_EMINJ_DEF base_data = { 基本値 };

// 調停された機能のdataget呼び出し
vdg_selected_function_dataget( &request_data );

// 統合
if ( request_data.u4_einjrq_dat & RQINJMODE ) {
    // 噴射モードは要求値を使用
    result.einjmod = request_data.einjmod;
} else {
    // 噴射モードは基本値を使用
    result.einjmod = base_data.einjmod;
}
```

#### 要求フラグの役割
- ビット単位で各パラメータの要求有無を表現
- 要求していないパラメータは基本値を使用
- 部分的な要求も可能

---

## 補正係数の取得

### emkrichbモジュール連携

**呼び出し箇所:** 行2220-2450（推定）

**目的:**
- 噴射回数に応じた基本増量補正係数を取得
- リッチ補正の適用

**処理:**
```c
vdg_emkrichb_ekrichxb_get( 噴射モード, &補正係数配列 );

for ( バンク数分ループ ) {
    s2t_krichxbcrt[bank] = 補正係数配列[bank];
}
```

**仕様書対応:**
- セクションA「噴射モード調停後にemkrichbをコールし、噴射回数に応じた現在基本増量補正係数を取得する」

---

## 同時性の確保

### 仕様書要求（要求1-3）
> 調停された各機能が要求した噴射モード、噴射開始時期、始動時噴射量、噴射量算出係数、噴射量補正係数、始動後噴射量要求フラグ等を同時性を確保してSACに公開する。

### 実装方法

#### 1. バッファリング
```c
// ローカル変数にコピー（割り込み保護）
st_EMINJ_EINJ stt_injdat_local = stg_eminj_einj;
```

#### 2. 一括更新
```c
vds_eminj_einj_dataset( &stg_eminj_einj, &調停結果, ON );
```

#### 3. NE割り込み考慮
```c
if ( u1s_eminj_exnercdfew == ON ) {
    // NE割り込みタスク実行中
    // 噴射量等の更新を実施
} else {
    // 通常タスク
    // 噴射量の更新をスキップ
}
```

**目的:**
- NE割り込みによるデータ不整合を防止
- 噴射制御の精度確保

---

## SAC連携

### 噴射要求受付処理

**呼び出し箇所:** 行2583（推定）

**関数:**
```c
vdg_ainjif_renew_injrq();
```

**タイミング:**
- 8msm処理の最後
- 全ての調停処理完了後

**仕様書対応:**
- 要求2「本部品の8msm処理実施後にSACの噴射要求受付関数をコールする」

**目的:**
- アプリとSACの同時性確保
- 噴射と点火の連動制御実現

---

## フェーズ遷移図

```
[電源ON]
    ↓
[初期化] ← vdg_eminj_pwon()
    ↓
[始動待機]
    ↓
[始動開始] → 始動フラグON
    ↓
[始動時調停フェーズ]
    ├─ 始動時優先度あり
    ├─ 始動時テーブル使用
    └─ 調停ID記憶
    ↓
[始動完了判定]
    ↓
[始動後調停フェーズ]
    ├─ 始動後優先度あり
    ├─ 始動後テーブル使用
    └─ 始動時機能の継続判定
    ↓
[暖機完了]
    ↓
[通常調停フェーズ]
    ├─ 通常優先度
    ├─ 通常テーブル使用
    └─ 定常運転制御
    ↓
[運転継続]
```

---

## 調停ロジックのフローチャート

```
START (vdg_eminj_8msm)
  ↓
[1. 初期化]
  ↓
[2. 始動状態判定]
  ├─ 始動中？
  │   ├─ YES: u1s_eminj_exast = ON
  │   └─ NO:  u1s_eminj_exast = OFF
  ↓
[3. 優先度取得]
  ├─ 各機能モジュールから優先度を取得
  ├─ u1s_eminj_estpri（始動時）
  ├─ u1s_eminj_eastpri（始動後）
  └─ u1s_eminj_epri（通常）
  ↓
[4. フェーズ判定]
  ├─ u1s_eminj_estpri != 0?
  │   ├─ YES: [始動時調停]へ
  │   └─ NO: 次へ
  ├─ u1s_eminj_eastpri != 0?
  │   ├─ YES: [始動後調停]へ
  │   └─ NO: 次へ
  └─ [通常調停]へ
  ↓
[5. 調停テーブル走査]
  ├─ ID順にループ
  ├─ 優先度一致で選択
  └─ dataget関数呼び出し
  ↓
[6. データ統合]
  ├─ 要求フラグチェック
  ├─ 要求値 or 基本値を選択
  └─ 統合データ作成
  ↓
[7. 補正係数取得]
  └─ vdg_emkrichb_ekrichxb_get()
  ↓
[8. 構造体セット]
  ├─ vds_eminj_einj_dataset()（旧）
  └─ vds_eminj_eminj_dataset()（新）
  ↓
[9. 公開変数更新]
  ├─ s2g_eminj_xxx
  ├─ f4g_eminj_xxx
  └─ u1g_eminj_einjmedislid
  ↓
[10. SAC連携]
  └─ vdg_ainjif_renew_injrq()
  ↓
END
```

---

## デバッグ・診断

### 調停ID確認
```c
u1 current_function_id = u1g_eminj_einjmedislid;
```
- 現在どの機能が調停されているかを確認可能

### 優先度確認
```c
u1 start_pri   = u1s_eminj_estpri;   // 始動時優先度
u1 afstart_pri = u1s_eminj_eastpri;  // 始動後優先度  
u1 normal_pri  = u1s_eminj_epri;     // 通常優先度
```
- 各フェーズの優先度状態を確認可能

### 要求フラグ確認
```c
u4 request_flags = stg_eminj_einj.u4_einjrq_dat;
```
- どのパラメータが要求されているかを確認可能

---

## まとめ

### 調停の3原則
1. **フェーズ優先**: 始動時 > 始動後 > 通常
2. **機能優先**: 噴射停止 > 工場 > ドラビリ > エミ > 保護 > 性能
3. **ID優先**: 同フェーズ内ではID小が優先

### 重要ポイント
- 始動時機能の始動後継続性
- 要求フラグによる部分的要求
- NE割り込みとの同時性確保
- SAC連携タイミング

### 拡張性
- テーブル追加で新機能対応可能
- ID体系で優先度管理が容易
- コンパイルスイッチで柔軟な構成

---

生成日: 2025-11-07
